# -*- coding: utf-8 -*-
"""Car_insurance.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UY-SU9HnUd5j6BDNj9ChvhNOer9idTda

# Context 

An Insurance company that has provided Health Insurance to its customers now wants to obtain a model to predict whether their customers from the past year would also be interested in Vehicle Insurance provided by the same company.

**Useful terms:**

 > _An_ **insurance policy** _is an arrangement by which a company undertakes to provide a guarantee of compensation for specified loss, damage, illness, or death in return for the payment of a specified premium._

 > _A_ **premium** _is a sum of money that the customer needs to pay regularly to an insurance company for this guarantee._

As in case of the medical insurance, the vehicle insurance is where every year the customers need to pay a _premium_, a certain amount of money, for insurance to the insurance provider company, so that in case anything happens to the vehicle, the insurance provider company will provide a compensation to the customer.

The insurance company would benefit from building a model to predict who would be more interested in Vehicle insurance, as it would help them reach out in a more efficient way to the right category of customers, who would respons positively to such an insurance offer.

For building the prediction model to estimate if a customer would be interested in Vehicle insurance, a dataset is given with information about demographics (gender, age, region code type), Vehicles (Vehicle Age, Damage), Policy (Premium, sourcing channel) etc.

# Data description

1. **id** =	Unique ID for the customer
2. **Gender** =	Gender of the customer
3. **Age** =	Age of the customer
4. **Driving_License** =	0 : Customer does not have DL, 1 : Customer already has DL
5. **Region_Code** =	Unique code for the region of the customer
6. **Previously_Insured** =	1 : Customer already has Vehicle Insurance, 0 : Customer doesn't have Vehicle Insurance
7. **Vehicle_Age** =	Age of the Vehicle
8. **Vehicle_Damage** =	1 : Customer got his/her vehicle damaged in the past. 0 : Customer didn't get his/her vehicle damaged in the past.
9. **Annual_Premium** =	The amount customer needs to pay as premium in the year
10. **PolicySalesChannel** = Anonymized Code for the channel of outreaching to the customer ie. Different Agents, Over Mail, Over Phone, In Person, etc.
11. **Vintage** =	Number of Days, Customer has been associated with the company
12. **Response** =	1 : Customer is interested, 0 : Customer is not interested

# Task

The task is to **predict if a customer would be interested in Vehicle insurance** based on some previously collected data.

# 1. Data Gathering

Load the data using the Pandas library:
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

train_data_file_path = "train.csv"
test_data_file_path = "test.csv"

train_data = pd.read_csv(train_data_file_path,on_bad_lines='skip')
test_data = pd.read_csv(test_data_file_path,on_bad_lines='skip')

"""We start by observing the description of the data:"""

train_data.describe().T

"""From the data description, we can observe the range of domain values for each feature, that is how many distinct values are present, what is the average, min or max value, below which values are 50% of the data, etc.
* Interesting to note here is that 75% of the people queried are less than 49 years old, middle-aged, and the min respectively the max ages are 20 and 85, so the survey mainly relates to the adults of the working class.
* Another interesting thing to note is that for everyone the vintage (nr of days the customer has been associated with the company) is less than a year, the max value is 299 days. So every customer of the insurance company is relatively new.
* Regarding the annual premium paid by each customer, the values are relatively close to each other, clustered around an average value of 30564.38, as the mean value shows. The max annual premium paid is 540165, but 75% of the customers pay less than 39400 a year, which is still close to the mean value. Therefore, the prices are relatively close to each other, only a few customers pay more than 39400.

Then, we are curious about the type of each feature and the number of non-null values:

Preview of the data and the data structure:
"""

train_data.head()

train_data.info()

"""**Observations:**
- The dataset contains 381109 rows and 12 columns
- There are no Null values
- There are 5 categorical and 4 numerical features
- The dependent feature is the 'Response' column

# 2. Data Visualization

In order to understand better the given data, we try to visualize the relationship between different features and how they affect the final response of the customer, by generating plots and graphs.

An initial look at the data with histograms:
"""

train = train_data.copy()

sns.set_style("whitegrid")
sns.set_palette("hls",8)

train.hist(bins=50, figsize=(20,15))
plt.show()

"""First, we study the features independently, then by comparing it to other features.

## Categorical features

For the features which contain categories of values, we generate plots to visualize the partition of the data into distict categories. 
The category features are the following:
* Driving_License = {0, 1} (* show if the customer has a driving license *)
* Gender = {Male, Female}
* Vehicle_Age = {<1 year, 1-2 years, > 2 years}
* Vehicle_Damage = {No, Yes} (* shows whether or not the customer's car has been damaged before *)
* Previously_Insured = {0, 1} (* shows if the customer already had a car insurance before *)

* **Driving license**

First, we analyze the response of the customers relative to whether or not they own a driving license:
"""

fig, (ax1, ax2) = plt.subplots(1,2, figsize=(15,6))
ax1.set_title('Driving_License distribution')
g1 = sns.countplot(x=train.Driving_License, ax=ax1)
g1.set(yscale = "log")
ax2.set_title('Driving_License vs Response')
sns.countplot(x = 'Driving_License', hue = 'Response', data = train,ax=ax2)
plt.show()

nr_drivers = len(train[train.Driving_License == 1])
nr_non_drivers = len(train[train.Driving_License == 0])
nr_positive_responses_drivers = len(train[(train.Driving_License == 1) & (train.Response == 1)])
ratio_of_positive_responses_drivers = nr_positive_responses_drivers/nr_drivers
print("Nr of customers having a driving license: " , nr_drivers)

print("   vs Nr of customers having NO driving license: " , nr_non_drivers)
print("Nr of positive responses customers having a driving license: " , nr_positive_responses_drivers)
print("Ratio of customers with a driving license responding positively: " + str(round(ratio_of_positive_responses_drivers,4)) + " (" + str(round(ratio_of_positive_responses_drivers * 100,2)) + "%) ")

"""From the first plot, we can see that most of the customers have a driving license, which is as we would expect.

What is more surprising, is the relatively small ratio of customers having a driving license, who responded positively to the possibilty of a car insurance, more precisely less than 13%. This would imply that having a driving license has little influence on the choice of the customer to pay for a car insurance.

* **Gender**

Next, we are curious to find out how the gender would affect the response of the customers:
"""

fig, (ax1, ax2) = plt.subplots(1,2, figsize=(15,6))
ax1.set_title('Gender distribution')
sns.countplot(x=train.Gender, ax=ax1)
ax2.set_title('Gender vs Response')
sns.countplot(x = 'Gender', hue = 'Response', data = train,ax=ax2)
plt.show()

nr_male_customers = len(train[train.Gender == 'Male'])
nr_positive_responses_male = len(train[(train.Gender == 'Male') & (train.Response == 1)])
ratio_of_positive_responses_male = nr_positive_responses_male/nr_male_customers
print("Nr of positive responses from male customers: " , nr_positive_responses_male)
print("Ratio of males responding positively: " + str(round(ratio_of_positive_responses_male,4)) + " (" + str(round(ratio_of_positive_responses_male * 100,2)) + "%) ")
print("-------------------------------------------------------------------------------")

nr_female_customers = len(train[train.Gender == 'Female'])
nr_positive_responses_female = len(train[(train.Gender == 'Female') & (train.Response == 1)])
ratio_of_positive_responses_female = nr_positive_responses_female/nr_female_customers
print("Nr of positive responses from female customers: " , nr_positive_responses_female)
print("Ratio of females responding positively: " + str(round(ratio_of_positive_responses_female,4)) + " (" + str(round(ratio_of_positive_responses_female * 100,2)) + "%) ")

"""As we can see, among the customers there is a fairly equal number of male and female, so the dataset is balanced from the point of view of the gender.

Although for both genders, the number of responses is predomninantly negative, the Response of the customers related to the gender shows that the ratio of males responding positively is greater than the ratio of women. Therefore, it can be said that men are more interested in car insurance than women are.

* **Age of the vehicle**

Before analyzing the data related to the age of the vehicles, our initial intuition would be that as the age of the car increases, the interest of the customers for a car insurance also rises. This is due to the fact that older cars need more maintainance than newer models, for example, some parts get worn out or break down and need some replacement.
"""

fig, (ax1, ax2) = plt.subplots(1,2, figsize=(15,6))
ax1.set_title('Vehicle_Age distribution')
sns.countplot(x=train.Vehicle_Age, ax=ax1)
ax2.set_title('Vehicle_Age vs Response')
sns.countplot(x = 'Vehicle_Age', hue = 'Response', data = train,ax=ax2)
plt.show()

nr_new_vehicles = len(train[train.Vehicle_Age == '< 1 Year'])
nr_positive_responses_new_vehicles = len(train[(train.Vehicle_Age == '< 1 Year') & (train.Response == 1)])
ratio_of_positive_responses_new_vehicles = nr_positive_responses_new_vehicles/nr_new_vehicles

print("Nr of customers with vehicles of age < 1 Year: ", nr_new_vehicles)
print("Nr of positive responses from customers with vehicles of age < 1 Year: " , nr_positive_responses_new_vehicles)
print("Ratio of customers with cars < 1 Year of age responding positively: " + str(round(ratio_of_positive_responses_new_vehicles,4))  + " (" + str(round(ratio_of_positive_responses_new_vehicles * 100,2)) + "%) ")
print("----------------------------------------------------------------------------------------")

nr_young_vehicles = len(train[train.Vehicle_Age == '1-2 Year'])
nr_positive_responses_nr_young_vehicles = len(train[(train.Vehicle_Age == '1-2 Year') & (train.Response == 1)])
ratio_of_positive_responses_young_vehicles = nr_positive_responses_nr_young_vehicles/nr_young_vehicles
print("Nr of customers with vehicles of age 1-2 Year: ", nr_young_vehicles)
print("Nr of positive responses from customers with vehicles of age 1-2 Year: " , nr_positive_responses_nr_young_vehicles)
print("Ratio of customers with cars 1-2 Year of age responding positively: " + str(round(ratio_of_positive_responses_young_vehicles,4)) + " (" + str(round(ratio_of_positive_responses_young_vehicles * 100,2)) + "%) ")
print("----------------------------------------------------------------------------------------")

nr_old_vehicles = len(train[train.Vehicle_Age == '> 2 Years'])
nr_positive_responses_old_vehicles = len(train[(train.Vehicle_Age == '> 2 Years') & (train.Response == 1)])
print("Nr of customers with vehicles of age > 2 Years: ", nr_old_vehicles)
print("Nr of positive responses from customers with vehicles of age > 2 Year: " , nr_positive_responses_old_vehicles)
ratio_positive_responses_old_vehicles = nr_positive_responses_old_vehicles/nr_old_vehicles
print("Ratio of customers with cars > 2 Years of age responding positively: " + str(round(ratio_positive_responses_old_vehicles,4)) + " (" + str(round(ratio_positive_responses_old_vehicles * 100,2)) + "%) ")
print("----------------------------------------------------------------------------------------")

"""Most of the customers had relatively new cars with ages less than 1 year, and among those with such new cars, only a very small ratio, less than 5%, was interested in car insurance. Which is understandable as new cars are not supposed to break down very easily or need their parts replaced, however they are just as much at risk of being damaged in an accident or by some natural hazard, such as hail.

As the age of the car increases, the ratio of customers opting for a car insurance also increases, as it is shown in the case of the cars with age greater than 2 years. Although, the nr of older cars (age > 2 Years) is more than 10% smaller than the nr of new cars (age < 1 Year), the ratio of customers interested in a car insurance is almost 30%.

This clearly indicates that the customers having older cars are more interested in having an insurance for their cars.

* **Vehicle damage**

We would expect that people who once had their cars damaged would be more interested in a car insurance, in case the same would happen to them in the future.
"""

fig, (ax1, ax2) = plt.subplots(1,2, figsize=(15,6))
ax1.set_title('Vehicle_Damage distribution')
sns.countplot(x=train.Vehicle_Damage, ax=ax1)
ax2.set_title('Vehicle_Damage vs Response')
sns.countplot(x = 'Vehicle_Damage', hue = 'Response', data = train,ax=ax2)
plt.show()

nr_damaged_vehicles = len(train[train.Vehicle_Damage == 'Yes'])
nr_not_damaged_vehicles = len(train[train.Vehicle_Damage == 'No'])
nr_positive_responses_damaged_vehicles = len(train[(train.Vehicle_Damage == 'Yes') & (train.Response == 1)])
nr_negative_responses_damaged_vehicles = len(train[(train.Vehicle_Damage == 'Yes') & (train.Response == 0)])
ratio_of_positive_responses_damaged_vehicles = nr_positive_responses_damaged_vehicles/nr_damaged_vehicles

print("Nr of customers having their vehicles previously damaged: ", nr_damaged_vehicles)
print("   vs Nr of customers having no previous damage to their vehicles: ", nr_not_damaged_vehicles)
print("Nr of POSITIVE responses of customers having their vehicles previously damaged: ", nr_positive_responses_damaged_vehicles)
print("   vs Nr of NEGATIVE responses of customers having their vehicles previously damaged: ", nr_negative_responses_damaged_vehicles)
print("Ratio of customers, having their vehicles previously damaged, who responded positively: "+ str(round(ratio_of_positive_responses_damaged_vehicles,4)) + " ("+ str(round(ratio_of_positive_responses_damaged_vehicles * 100,2)) + "%) ")

"""As the figures show, among the customers, around half of them had their cars previously damaged.

From the ones who already had some damage to their cars in the past, more than 23% have responded affirmatively to the option of having a car insurance, which shows:
* Firstly, that customers who already know the expenses of repairing a damaged car, are appreciating more the possibility of an insurance on their vehicles, to prevent future costs.
* Secondly, that previous damage to the vehicle has more influence on the response of the customers than having a driving license.

Another remark, is that on the second plot it seems that customers who had no previous damage to their cars all responded negatively to the offer of a car insurance, however after a closer look to the numbers, we can see that there are still a few people who would like to have an insurance on their cars even though they haven't suffered damage before.
"""

nr_positive_responses_not_damaged_vehicles = len(train[(train.Vehicle_Damage == 'No') & (train.Response == 1)])
nr_negative_responses_not_damaged_vehicles = len(train[(train.Vehicle_Damage == 'No') & (train.Response == 0)])
print("Nr of POSITIVE responses of customers having no previous damage to their vehicles: ", nr_positive_responses_not_damaged_vehicles)
print("Nr of NEGATIVE responses of customers having no previous damage to their vehicles: ", nr_negative_responses_not_damaged_vehicles)

"""This means that the scale of the nr of customers with previous vehicle damage and the nr of customers with positive response doesn't match. This can be corrected however, by using a logarithmic scale for the nr of responses."""

plt.title('Vehicle_Damage vs Response')
g = sns.countplot(x = 'Vehicle_Damage', hue = 'Response', data = train)
g.set(yscale="log")
plt.show()

"""##### _Vehicle_Damage vs other features_"""

fig, axes = plt.subplots(1,5, figsize=(32,6))

axes[0].pie( x= train.groupby('Vehicle_Damage')['Previously_Insured'].count(), 
            labels=train['Vehicle_Damage'].unique(), autopct='%1.1f%%', 
            shadow=True, colors = sns.color_palette('Set2'))
axes[0].set_title('Vehicle_Damage vs Previously_Insured')
axes[0].legend(labels=train['Previously_Insured'].unique(), title = "Previously_Insured", 
           fontsize = 'large', title_fontsize = "10")

sns.countplot(hue = 'Vehicle_Damage', x = 'Previously_Insured', data = train,ax=axes[1], palette='Set2')
axes[1].set_title('Vehicle_Damage vs Previously_Insured')

# transform Vehicle_Age to numerical value to be able to represent it
vehicle_age_encoded = train.copy()
vehicle_age_encoded['Vehicle_Age'] = vehicle_age_encoded['Vehicle_Age'].apply(lambda x: 0 if x == "< 1 Year" else 1 if x == "1-2 Year" else 2)

sns.countplot(hue = 'Vehicle_Damage', x = 'Vehicle_Age', data = train,ax=axes[2], palette='Set2_r')
axes[2].set_title('Vehicle_Damage vs Vehicle_Age')

axes[3].pie( x= train.groupby('Vehicle_Damage')['Age'].mean(), 
            labels=train['Vehicle_Damage'].unique(), autopct='%1.1f%%', 
            shadow=True,  colors = sns.color_palette('Set3'))
axes[3].set_title('Vehicle_Damage vs Age')
axes[3].legend(labels=train['Age'].unique(), title = "Age", 
           fontsize = 'large', title_fontsize = "10")

# transform gender to numerical value to be able to represent it
gender_encoded = train.copy()
gender_encoded['Gender'] = gender_encoded['Gender'].apply(lambda x: 1 if x == 'Male' else 0)

axes[4].pie( x= gender_encoded.groupby('Vehicle_Damage')['Gender'].sum(), 
            labels=gender_encoded['Vehicle_Damage'].unique(), autopct='%1.1f%%', 
            shadow=True)
axes[4].set_title('Vehicle_Damage vs Gender')
axes[4].legend(labels=train['Gender'].unique(), title = "Gender", 
           fontsize = 'large', title_fontsize = "10")


plt.show()

"""> **Observations**:
* _Vehicle_Damage vs Previusly_Insured_: Around half of those who had insurance on their cars before had suffered some damage to it.
* _Vehicle_Damage vs Vehicle_Age_: Newer cars, with age < 1 Year, were less likely to have damage to them, while the cars with ages 1-2 Years were the most likely to have had some damage to them before.
* _Vehicle_Damage vs Age_: Older Customers were more likely to have had damaged cars before than younger customers.
* _Vehicle_Damage vs Gender_: More female customers had damage to their cars before than male customers.

* **Previous insurance**

We would expect that, customers having had a car insurance previously would like to extend their insurance contract if they have a very old car or if they have had some damage to their vehicles, in which cases an insurance would seem very advantageous to them. 

Therefore, aside from analyizing the data of having a previous insurance relative to the positive response of the customers, it would also seem interesting to compare it against the age of the vehicle and the previous damage, to see if these combined would increase the number of positive responses or not.
"""

fig, (ax1, ax2) = plt.subplots(1,2, figsize=(15,6))
ax1.set_title('Previously_Insured distribution')
sns.countplot(x=train.Previously_Insured, ax=ax1)
ax2.set_title('Previously_Insured vs Response')
g = sns.countplot(x = 'Previously_Insured', hue = 'Response', data = train,ax=ax2)
g.set(yscale="log")
plt.show()

nr_prev_insured = len(train[train.Previously_Insured == 1])
nr_not_prev_insured = len(train[train.Previously_Insured == 0])
nr_positive_responses_prev_insured = len(train[(train.Previously_Insured == 1) & (train.Response == 1)])
nr_positive_responses_not_prev_insured = len(train[(train.Previously_Insured == 0) & (train.Response == 1)])
ratio_of_positive_responses_prev_insured = nr_positive_responses_prev_insured/nr_prev_insured

print("Nr of customers having previously insured: " , nr_prev_insured)
print("   vs Nr of customers having NO previous insurance: ", nr_not_prev_insured)
print("Nr of positive responses from customers having previously insured: " , nr_positive_responses_prev_insured)
print("   vs Nr of positive responses from customers having NO previous insurance: " , nr_positive_responses_not_prev_insured)
print("Ratio of customers having previously insured and responding positively: " + str(round(ratio_of_positive_responses_prev_insured,4)) + " (" + str(round(ratio_of_positive_responses_prev_insured * 100,2)) + "%) ")

"""As we can see, around half of the customers have had a car insurance before, but only 9 out of 10000 of them would like to have an insurance on their vehicles in the future as well. On the other side, from the customers who did not have a car insurance previously, half of them responded positively.

This means, that having had a car insurance previously doesn't increase the number of positive responses directly, however it could have a larger impact on the Responses of the customers if analyzed in combination with the Vehicle_Damage or the Vehicle_Age features.

##### _Previously_Insured vs other features_
"""

vehicle_damage = train[train.Vehicle_Damage == 'Yes']
no_vehicle_damage = train[train.Vehicle_Damage == 'No']

print("Previously_Insured vs Vehicle_Damage")

fig, (ax1, ax2) = plt.subplots(1,2, figsize=(15,6))
ax1.set_title('Had vehicle damage before')
g1 = sns.countplot(x = 'Previously_Insured', hue = 'Response', data=vehicle_damage, ax = ax1)
g1.set(yscale="log")
ax2.set_title('Had NO vehicle damage before')
g2 = sns.countplot(x = 'Previously_Insured', hue = 'Response', data=no_vehicle_damage, ax = ax2)
g2.set(yscale="log")
plt.show()

"""From the above plots, we can see that those who had NOT been previously insured but had suffered damage to their vehicles are more interested in a car insurance, than those who also have NOT been previously insured but had no damage to their cars yet, which is a reasonable outcome.

Next, we analyze the Previously_Insured w.r.t. Vehicle_Age:
"""

prev_insurance = train[train.Previously_Insured == 1]
no_prev_insurance = train[train.Previously_Insured == 0]

print("Previously_Insured vs Vehicle_Age")

fig, (ax1, ax2) = plt.subplots(1,2, figsize=(15,6))
ax1.set_title('Had previous insurance')
g1 = sns.countplot(x = 'Vehicle_Age', hue = 'Response', data=prev_insurance, ax = ax1)
g1.set(yscale="log")
ax2.set_title('Had NO previous insurance')
g2 = sns.countplot(x = 'Vehicle_Age', hue = 'Response', data=no_prev_insurance, ax = ax2)
g2.set(yscale="log")
plt.show()

"""From the plots, we can conclude that among the customers with vehicles of ages between 1-2 years, those who had no previous insurance were more interested in having an insurance in the future, than those who already owned one. 

Interesting to note that the customers owning newer cars, of less than 1 year, or older ones, of more than 2 years, were much less likely to have an insurance in the future, regardless of whether they had one before or not.

## Numerical features

Next, for the features containing numerical values we generate distribution plots to analyze the influence of these values on the final response of the customers.

Numerical feautures are:
* Age: between 20 to 85 years
* Annual_Premium: how much the customer has to pay for insurance in a year, ranges between 2630.0	to max 540165.0
* Vintage: how long the customer has been associated with the insurance company, ranges between 10 to 299 days
* Policy_Sales_Channel: 163 distinct channels, encoded anonyomously, which represent the communication channel on which the customer can be reached, for ex. phone, mail, webpage announcement, etc.
* Region_Code: between 0 to 52, which represent the encoding of the region where the customer lives

#### **Age**

First, we look at how the age influences the choice of the customer of opting for a car insurance:
"""

sns.displot(x = 'Age', data = train, height = 6, aspect=15/8)
plt.title('Customer Age distribution')
plt.show()

"""As we can see the ages are quite varying, but there are some clusters around specific ranges, therefore we can distinguish 3 age groups:
* young: 20-30
* middle-aged: 30-50
* old: 50-80

As we can see from the distribution plot, most of the customers are young, with ages between 20-30 years, or middle aged, between 40-50 years, representing the working class.
"""

sns.catplot(x="Response", y='Age', data=train, kind="violin")
plt.title("Customer Age distribution with Response")
plt.show()

# categorize the 'Age' feature
train['Age_Group'] = train['Age'].apply(lambda x:'Young' if x<30 else 'MiddleAged' if x<50 else 'Old')

fig, (ax1,ax2) = plt.subplots(1, 2, figsize=(15,8))

sns.countplot(x = 'Age_Group', data = train, hue='Response',ax=ax1)
ax1.set_title("Age_Group distribution with Respose")

ax2.pie( x= train.groupby('Age_Group')['Response'].sum(), 
            labels=train['Age_Group'].unique(), autopct='%1.1f%%', 
            shadow=True)
ax2.set_title("Age_Group distribution with Respose")

plt.show()

"""Looking at the above plot and analyzing the Responses relative to the ages of the customers we find out that *Middle-Aged* customers with ages between 30-50 years, and *Older* customers above the age of 50, had the majority of positive responses, which means they were more interested in having a car insurance, than *Young* customers with ages between 20-30."""

nr_young = len(train[train.Age_Group == 'Young'])
nr_positive_responses_young = len(train[(train.Age_Group == 'Young') & (train.Response == 1)])
ratio_of_positive_responses_young = nr_positive_responses_young/nr_young

print("Nr of young customers: " , nr_young)
print("Nr of positive responses from young customers: " , nr_positive_responses_young)
print("Ratio of positive responses from young customers: " ,  str(round(ratio_of_positive_responses_young,4)) + " (" + str(round(ratio_of_positive_responses_young * 100,2)) + "%) ")
print("--------------------------------------------------------------------------------------------------------")

nr_middle_aged = len(train[train.Age_Group == 'MiddleAged'])
nr_positive_responses_middle_aged = len(train[(train.Age_Group == 'MiddleAged') & (train.Response == 1)])
ratio_of_positive_responses_middle_aged = nr_positive_responses_middle_aged/nr_middle_aged

print("Nr of middleAged customers: " , nr_middle_aged)
print("Nr of positive responses from middleAged customers: " , nr_positive_responses_middle_aged)
print("Ratio of positive responses from middleAged customers: " ,  str(round(ratio_of_positive_responses_middle_aged,4)) + " (" + str(round(ratio_of_positive_responses_middle_aged * 100,2)) + "%) ")
print("--------------------------------------------------------------------------------------------------------")

nr_old = len(train[train.Age_Group == 'Old'])
nr_positive_responses_old = len(train[(train.Age_Group == 'Old') & (train.Response == 1)])
ratio_of_positive_responses_old = nr_positive_responses_old/nr_old

print("Nr of old customers: " , nr_old)
print("Nr of positive responses from old customers: " , nr_positive_responses_old)
print("Ratio of positive responses from old customers: " ,  str(round(ratio_of_positive_responses_old,4)) + " (" + str(round(ratio_of_positive_responses_old * 100,2)) + "%) ")
print("--------------------------------------------------------------------------------------------------------")

"""However, comparing the ratio of positive and negative responses per age category, our the calculations show, that 4% of the younger customers wanted a car insurance, 20% of the middle aged ones, and 13% of the retired customers. From here, we can conclude that the insurance in the vehicle is more popular among the middle-aged and older generations, and young customers had the most negative answers.

This tells us, that age indeed, represents an important factor in determining whether or not a customer would be interested in a car insurance.

##### _Age vs other features_
"""

fig, (ax1,ax2,ax3) = plt.subplots(1, 3, figsize=(22,8))

sns.histplot(binwidth=0.5, x="Age_Group", hue="Previously_Insured", stat="count", multiple="stack", data=train,ax=ax1)
ax1.set_title("Age_Group distribution with Previously_Insured")

sns.lineplot(x="Age",y="Annual_Premium", hue="Gender",data=train, ax = ax2)
ax2.set_title("Age distribution with Annual_Premium and Gender")

sns.histplot(x="Age_Group",y="Vehicle_Age",data=train,  cbar=True, cbar_kws=dict(shrink=.75), ax = ax3)
ax3.set_title("Age_Group vs Vehicle_Age")

plt.show()

"""**Observations**:
* _Age_Group vs Previously_Insured_: _Young_ people are the most likely to have had an insurance previously, while the older generations, _MiddleAged_ and _Old_ are less likely to have been insured before.
* _Age vs Annual_Premium_: Younger customer with ages between 20-30, are more likely to pay a larger sum for insurance, as well as those with ages 50-80. The customer with ages between 30-50 are paying the least amount for annual premium.
* _Age_Group vs Vehicle_Age_: _Young_ customers tend to have newer cars, with age < 1 Year, while the older generations have cars with age between 1-2 years, and only few have cars older than 2 years.

#### **Annual premium**

The annual premium paid for insurance should be measured against the income of a person, but in this case we do not have data about how much the customers earn. 

As an initial guess, we would assume that those who already pay very much for an insurance would be less interested in having a car insurance, than those who pay a reasonable amount.
"""

sns.displot(train.Annual_Premium, kind="kde", common_norm=False)
plt.title('Annual premium distribution')
plt.show()

"""From the above plot, we can see that there are some values which lie very much outside the common range of values, which distort the plot as well, the figure appearing strongly right-skewed."""

UpperLimit = 2.5 * train['Annual_Premium'].quantile(0.75) - 1.5 * train['Annual_Premium'].quantile(0.25)
# remove oulier values based on the previously computed UpperLimit
train['Annual_Premium_Treated'] = np.where(train['Annual_Premium']>UpperLimit, UpperLimit, train['Annual_Premium'])

from sklearn.preprocessing import MinMaxScaler

scaler = MinMaxScaler()
# normalize the data to fit in the scale of [0,1] for better visualization
train['Annual_Premium_Treated'] = scaler.fit_transform(train['Annual_Premium_Treated'].values.reshape(-1,1))

fig, (ax1,ax2) = plt.subplots(1, 2, figsize=(15,8))
sns.boxplot(ax = ax1, y = 'Annual_Premium_Treated',x = 'Response', data = train)
ax1.set_title("Annual Premium vs Response")
sns.distplot(ax = ax2, x = train['Annual_Premium_Treated'])
ax2.set_title("Annual Premium distribution with Response")

"""After removing the outlier values and rescaling the range of values, we observe form the plots that most of the people pay around the same amount of Annual Premium, and the responses were also balanced for those who pay a fairly similar amount for Annual Premium, therefore, it doesn't influence the customer's response as much as one would expect.

##### _Annual_Premium_Treated vs other features_
"""

fig, (ax1,ax2,ax3,ax4) = plt.subplots(1, 4, figsize=(25,8))

sns.barplot(x = 'Age_Group',y = 'Annual_Premium_Treated', data= train, ax=ax1)
ax1.set_title("Annual_Premium_Treated vs Age_Group")

sns.boxplot( x = 'Vehicle_Age', y = 'Annual_Premium_Treated', hue = 'Vehicle_Damage', data=train ,ax=ax2)
ax2.set_title("Annual_Premium_Treated vs Vehicle_Age and Vehicle_Damage")

sns.pointplot(x="Previously_Insured",y="Annual_Premium_Treated",data=train, ax = ax3)
ax3.set_title("Annual_Premium_Treated vs Previously_Insured")

ax4.hexbin(x="Vintage", y="Annual_Premium_Treated", data=train, gridsize = 30, cmap='flare')
ax4.set_title("Annual_Premium_Treated vs Vintage")

plt.show()

"""> **Observations**:
* _Annual_Premium_Treated vs Age_Group_: it seems that _Old_ customers have to pay the most for annual premium, and _MiddleAged_ customers pay less.
* _Annual_Premium_Treated vs Vehicle_Age and Vehicle_Damage_: Customers with cars older than 2 years with no previous damage pay the smallest amount of annual premium, while those who have older cars which have been damaged before, pay the largest amount. Customers with newer cars pay roughly the same amount for Annual premium, independent of whether the car has been damaged before or not.
* _Annual_Premium_Treated vs Previously_Insured_: it seems that customers who have been previously insured have to pay more for Annual premium than those who have not been insured before.
* _Annual_Premium_Treated vs Vintage_: The majority of the customers pay the same amount of money for annual insurance, an average value, independent of their vintage.

#### **Vintage**

As it shows in the plot below, the Vintage value is equally dispersed among the customers, meaning that there are customers who joined the company only recently, or those who have been associated with the insurance company from longer ago. No customer has been associated with the company for more than a year, which means all of them are relatively new customers.
"""

sns.displot(x = train['Vintage'])
plt.title("Vintage distribution")
plt.show()

sns.catplot(y = 'Vintage',x = 'Response', data = train, kind="box")
plt.title("Vintage vs Response")
plt.show()

"""Analyzing the response of the customers relative to their vintage, we can see that the vintage value is between 100-230 for the majority of them, and their responses are divided equally. Therefore, the Vintage is not so relevant for the Response feature."""

fig, (ax1,ax2,ax3) = plt.subplots(1, 3, figsize=(22,8))

sns.lineplot( x="Age_Group", y="Vintage", hue = 'Response', data=train,ax=ax1)
ax1.set_title("Vintage vs Age_Group")

sns.stripplot( x="Age_Group", y="Vintage", hue = 'Response', data=train,ax=ax2)
ax2.set_title("Vintage vs Age_Group")

sns.boxplot( x = 'Previously_Insured', y = 'Vintage', hue = 'Response', data=train ,ax=ax3)
ax3.set_title("Vintage vs Previously_Insured and Response")

plt.show()

"""> **Observations**:
*  _Vintage vs Age_Group_: MiddleAged customers who have been associated with the company for longer (have higher Vintage) also have the most positive responses, while Young customers who have been associated with the insurance company for longer had the most negative responses.
* _Vintage vs Previously_Insured_: The Vintage value of the customers doesn't affect the Previously_Insured and Response features, as we can see for both insured and not insured customers, the responses were equally distributed.

* **Region_Code**
"""

sns.displot(x = train['Region_Code'])
plt.title("Region_Code distribution")
plt.show()

"""From the above plot, we can see that there appear to be region codes from of every value between the rage 0-52, but there are also 3 higher peaks, between below 40000, above 100000 and around 20000.

Therefore, we can distinguish 3 categories for the region codes:
* Region_A: representing those regions from where more than 100000 customers come
* Region_B: those regions belong here which have between 10000 and 35000 customers
* Region_C: regions with less than 10000 customers.
"""

# Categorizing Region Code feature
x = train['Region_Code'].value_counts().apply(lambda x: 'Region_A' if x>100000 else 'Region_B' if x>11000 and x<340000 else 'Region_C')
category_map = dict(zip(x.keys(),x.values))
train['Region_Code_Group'] = train['Region_Code'].map(category_map)

sns.countplot(x = 'Region_Code_Group', data = train, hue='Response')
plt.title("Region_Code_Group vs Response")
plt.show()

"""After projecting the response of the customers on the 3 new regions, we can see that most of the positive responses came from regions A and C, but most of the negative responses came also from region C."""

fig, (ax1,ax2) = plt.subplots(1, 2, figsize=(15,8))

ax1.pie( x= train.groupby('Region_Code_Group')['Vintage'].sum(), 
            labels=train['Region_Code_Group'].unique(), autopct='%1.1f%%', 
            shadow=True)
ax1.set_title("Region_Code_Group distribution with Vintage")

ax2.pie( x= train.groupby('Region_Code_Group')['Annual_Premium'].sum(), 
            labels=train['Region_Code_Group'].unique(), autopct='%1.1f%%', 
            shadow=True);
ax2.set_title("Region_Code_Group distribution with Annual_Premium")

plt.show()

"""> **Observation**:
* _Region_Code_Group vs Vintage_: The customers belonging to Region_B had the highest Vintage values and the newest customers come from Region_A.
* _Region_Code_Group vs Annual_Premium_: customers from Region_B and Region_A pay almost the same amount of annual premium for insurance.

* **Policy Sales Channel**
"""

sns.displot(x = train['Policy_Sales_Channel'])
plt.title("Policy_Sales_Channel distribution")
plt.show()

"""Similarly, as in case of the Region_Code feature, we can observe that the Policy_Sales_Channel codes also take all the values in the range 0-160. The 4 peaks indicate that the most customers can be reached on channels encoded with 25, 125 150 and 160 labels.

In order to better visualize the plots, we differentiate again 3 categories, as indicated by the 4 peak values and distribute the policy channels into these categories:
* Channel_A : those channels which allow reaching more than 100000 customers. These are the most effective communication channels.
* Channel_B: those channels on which the company can reach around 75000-100000 customers
* Channel_C: which can reach out to between 10000-75000 customers
* Channel_D: which can reach out less than 10000 customers. These are the less effective communication channels.
"""

x = train['Policy_Sales_Channel'].value_counts().apply(lambda x: 'Channel_A' if x>100000 else 'Channel_B' if 75000<x<100000 else 'Channel_C' if 10000<x<=75000 else 'Channel_D') 
category_map = dict(zip(x.keys(),x.values))
train['Policy_Sales_Channel_Group'] = train['Policy_Sales_Channel'].map(category_map)

sns.countplot(x = 'Policy_Sales_Channel_Group', data = train, hue='Response')
plt.title("Policy_Sales_Channel_Group vs Response")
plt.show()

"""From the plot it show that Channel_B and Channel_C are the most effective ways of reaching the customers in order to inform them about the possibility of a car insurance, as they have the most positive responses. Channel_A seems to be the worst choice as it has few positive responses and it also had the most negative responses."""

fig, (ax1,ax2,ax3, ax4) = plt.subplots(1, 4, figsize=(27,8))

sns.pointplot( y="Vintage", x="Policy_Sales_Channel_Group", data=train,ax=ax1)
ax1.set_title("Policy_Sales_Channel_Group vs Vintage")

sns.barplot( y = 'Response', hue="Gender", x="Policy_Sales_Channel_Group", data=train,ax=ax2)
ax2.set_title("Policy_Sales_Channel_Group vs Gender")

sns.histplot( hue="Age_Group", x="Policy_Sales_Channel_Group", data=train,ax=ax3)
ax3.set_title("Policy_Sales_Channel_Group vs Age_Group")

sns.barplot( y = 'Response', hue="Region_Code_Group", x="Policy_Sales_Channel_Group", data=train,ax=ax4)
ax4.set_title("Policy_Sales_Channel_Group vs Region_Code_Group")

plt.show()

"""> **Observations**:
* _Policy_Sales_Channel_Group vs Vintage_: Customers who have been with the insurance company were reached mainly through channels from category Channel_A, while newer customers through channels from category Channel_D.
* _Policy_Sales_Channel_Group vs Gender_: The number of male and female customers were reached out through each channel is equally distributed, therefore Gender doesn't really affect the distribution. However, interesting to note that the least popular channels to contact customers were proven to be from category Channel_A.
* _Policy_Sales_Channel_Group vs Age_Group_: Most of the Young customers could be reached through channels from category Channel_A, MiddleAged customer were reached through channels from categories Channel_C and Channel_D, while Old customers through channels from catgeories Channel_C.
* _Policy_Sales_Channel_Group vs Region_Code_Group_: Most of the customers from regions of category Region_A were reached through channels from Channel_B. The customers from Region_B and Region_C were mainly reached through Channel_B and Channel_D. Again, through Channel_A were reached the least amount of customers, independent of region.

## Data pre-processing for categorical features
As we have seen, some of these categorical features, mainly those which represent more than 2 (binary) categories, contain values in form of a text, which have to be encoded using numerical labels in order to use them later for our model.

Using a LabelEncoder we can assign a unique numerical code for each distinct category inside a feature, and the final form of the data becomes:
* for binary categories 0 represents if the property is present, 1 if it is missing, for ex. having or not having a Driving license/Previous insurance/Damage to the vehicle. In case of Gender, 1 means 'Male', while 0 means 'Female'.
* as for the categories with multiple values, in this case only the Vehicle_Age, 0 stands for '1-2 Years', 1 means having '< 1 Years' and 2 for '> 2 Years.
"""

# copy the initial data
train_prep = train_data.copy()

# categorize the Age feature
train_prep['Age_Group'] = train_prep['Age'].apply(lambda x:'Young' if x<30 else 'MiddleAged' if x<50 else 'Old')

# categorize Region_Code feature
x = train_prep['Region_Code'].value_counts().apply(lambda x: 'Region_A' if x>100000 else 'Region_B' if x>11000 and x<340000 else 'Region_C')
category_map = dict(zip(x.keys(),x.values))
train_prep['Region_Code_Group'] = train_prep['Region_Code'].map(category_map) 

# categorize Policy_Sales_Channel feature
x = train_prep['Policy_Sales_Channel'].value_counts().apply(lambda x: 'Channel_A' if x>100000 else 'Channel_B' if 75000<x<100000 else 'Channel_C' if 10000<x<=75000 else 'Channel_D') 
category_map = dict(zip(x.keys(),x.values))
train_prep['Policy_Sales_Channel_Group'] = train_prep['Policy_Sales_Channel'].map(category_map)

train_encoded = train_prep.copy()

from sklearn.preprocessing import LabelEncoder

# assign labels for each category
le = LabelEncoder()
categorical_features = ['Gender', 'Vehicle_Age','Vehicle_Damage','Previously_Insured','Age_Group','Policy_Sales_Channel_Group', 'Region_Code_Group']
train_encoded[categorical_features] = train_encoded[categorical_features].apply(le.fit_transform)
train_encoded.head()

"""## Remove outlier values for numerical features

Remove the values which are very far from the majority of the values, because they could cause problems adn introduce errors, distortions in the prediction model. This approch is repeated for Annual_Premium and Vintage features, as they are the ones which contain outlier values, as previously shown in the plots.
"""

# compute the upper limit which represents a threshold for filtering out the outlier values
def get_upper_limit(x):
  upper_limit = 2.5 * x.quantile(0.75)  - 1.5 * x.quantile(0.25)
  return upper_limit

# import the MinMaxScaler in order to use it to rescale the range of values
from sklearn.preprocessing import MinMaxScaler

scaler = MinMaxScaler()

upper_limit_for_Annual_Premium = get_upper_limit(train_encoded['Annual_Premium'])

# remove oulier values based on the previously computed UpperLimit
train_encoded['Annual_Premium_Treated'] = np.where(train_encoded['Annual_Premium'] > upper_limit_for_Annual_Premium, upper_limit_for_Annual_Premium, train_encoded['Annual_Premium'])

# normalize the data to fit in the scale of [0,1] for better visualization
train_encoded['Annual_Premium_Treated'] = scaler.fit_transform(train_encoded['Annual_Premium_Treated'].values.reshape(-1,1))

upper_limit_for_Vintage = get_upper_limit(train_encoded['Vintage'])

# remove oulier values based on the previously computed UpperLimit
train_encoded['Vintage_Treated'] = np.where(train_encoded['Vintage'] > upper_limit_for_Vintage, upper_limit_for_Vintage, train_encoded['Vintage'])

# normalize the data to fit in the scale of [0,1] for better visualization
train_encoded['Vintage_Treated'] = scaler.fit_transform(train_encoded['Vintage_Treated'].values.reshape(-1,1))

train_encoded.describe().T

"""## Analyzing correlations between features

In order to determine which features have a greater influence on the Response, it is not enough to observe them individually, as they could influence one another in some way, therefore we are curious to find a relationship/correlation between some of the features and to isolate features that are completely independent of the others and may have no relevance to the result.

First, we get rid of the features which contain texts and non-numerical values, and keep only the numerical features:
"""

train_corr = train_encoded.copy()
unnecessary_columns = ['Region_Code', 'Age', 'Policy_Sales_Channel', 'Vintage', 'Annual_Premium']
train_corr = train_corr.drop(columns = unnecessary_columns, axis=1)
train_corr.head()

corr_matrix = train_corr.corr()
corr_matrix["Response"].sort_values(ascending=False)

# attributes which influence positively the Response attribute
important_attributes = ['Vehicle_Damage', 'Policy_Sales_Channel_Group','Gender','Annual_Premium_Treated','Driving_License']

"""The correlation between the independnet attributes and the target feature, Response, can be better understod when looking at a heatmap:"""

# generate a heatmap
fig, ax1 = plt.subplots(figsize=(10, 5), dpi=100)
sns.heatmap(corr_matrix, annot=True,fmt="0.2f", ax=ax1)
plt.show()

"""> We can see now that indeed, **Vehicle_Damage** has the highest _positive_ influence on the Response feature's value, while **Previously_Insured** has the highest _negative_ influence. These 2 features are strongly negatively correlated, having correlation factor -0.82. 

> In other words, those who have not been previously insured and had their cars damaged in the past, would be more interested in a car insurance than those, who had an insurance before but their car was not damaged. 
"""

sns.violinplot(x='Previously_Insured', y='Vehicle_Damage',data=train_corr)
plt.title('Previously_Insured vs Vehicle_Damage')
plt.show()

"""The violin plot above shows clearly that the two features, Previously_Insured and Vehicle_Damaged are strongly negatively correlated.

> At first glance, we can already tell from the heatmap which features have little to no affect on the result, the ones with correlation values very close to 0 for every other feature are: 
* **id**: it's completely independent of the other features, and also of the target feature, Response, therefore it is useless for the model.
* **Vintage_Treated**: also 0 correlation with all the other features.

Strong positive corelation between the following pairs of features:
* **Age_Group** and **Vehicle_Age**
* **Age_Group** and **Previously_Insured**
* **Age_Group** and **Region_Code_Group**
* **Vehicle_Damage** and **Policy_Sales_Channel_Group**
* **Vehicle_Age** and **Previously_Insured**
* **Region_Code_Group** and **Vehicle_Age**
* **Region_Code_Group** and **Previously_Insured**
* **Gender** and **Policy_Sales_Channel_Group**
"""

fig, (ax1,ax2,ax3) = plt.subplots(1, 3, figsize=(20,6))
sns.histplot(binwidth=0.5, x="Age_Group", 
                 hue="Previously_Insured", data=train, 
                 stat="count", multiple="stack",ax=ax1)
ax1.set_title("Age_Group vs Previously_Insured")
sns.pointplot(x="Age",y="Vehicle_Age", data=train,ax = ax2)
ax2.set_title("Age_Group vs  Vehicle_Age")
sns.histplot(binwidth=0.5, x="Age_Group", 
                 hue="Region_Code_Group", data=train, 
                 stat="count", multiple="stack",ax=ax3)
ax3.set_title("Age_Group vs Region_Code_Group")
plt.show()

"""> **Observations**:
* _Age_Group vs Previously_Insured_: Younger customers were more likely to have had a previous insurance, while MiddleAged and Old customers had not.
* _Age_Group vs Vehicle_Age_: Younger customers had newer cars, with age < 1 year, MiddleAged customers had mainly cars of 1-2 years and Old customers had rather older cars than 2 years. This shows that older generations were more likely to own also older vehicles.
* _Age_Group vs Region_Code_Group_: Younger customers were most likely from regions of category Region_C and Region_B, while the majority of the MiddleAge and Old customers came from regions from categories Region_A and Region_C.
"""

fig, axes = plt.subplots(4, 4, figsize=(25,20))

sns.histplot(binwidth=0.5, x="Age_Group", 
                 hue="Vehicle_Age", data=train_prep, 
                 stat="count", multiple="stack",ax=axes[0][0])
axes[0][0].set_title('Age_Group vs Vehicle_Age')
sns.catplot(x='Age_Group', y='Vehicle_Age',hue="Response",data=train_prep,ax=axes[0][1])
sns.swarmplot(x='Age_Group', y='Vehicle_Age',hue="Response",data=train_prep,ax=axes[0][1])
axes[0][1].set_title('Age_Group vs Vehicle_Age w.r.t. Response')

sns.histplot(binwidth=0.5, x="Age_Group", 
                 hue="Previously_Insured", data=train_prep, 
                 stat="count", multiple="stack",ax=axes[0][2])
axes[0][2].set_title('Age_Group vs  Previously_Insured')
sns.pointplot(x='Age_Group', y='Previously_Insured',hue="Response",data=train_prep,ax=axes[0][3])
axes[0][3].set_title('Age_Group vs Previously_Insured w.r.t. Response')

sns.histplot(binwidth=0.5, x="Age_Group", 
                 hue="Region_Code_Group", data=train_prep, 
                 stat="count", multiple="stack",ax=axes[1][0])
axes[1][0].set_title('Age_Group vs  Region_Code_Group')
sns.pointplot(x='Age_Group', y='Region_Code_Group',hue="Response",data=train_prep,ax=axes[1][1])
axes[1][1].set_title('Age_Group vs Region_Code_Group w.r.t. Response')

sns.histplot(binwidth=0.5, x="Vehicle_Damage", 
                 hue="Policy_Sales_Channel_Group", data=train_prep, 
                 stat="count", multiple="stack",ax=axes[1][2])
axes[1][2].set_title('Vehicle_Damage vs Policy_Sales_Channel_Group')
sns.pointplot(x='Vehicle_Damage', y='Policy_Sales_Channel_Group',hue="Response",data=train_prep,ax=axes[1][3])
axes[1][3].set_title('Vehicle_Damage vs Policy_Sales_Channel_Group w.r.t. Response')

sns.histplot(binwidth=0.5, x="Vehicle_Age", 
                 hue="Previously_Insured", data=train_prep, 
                 stat="count", multiple="stack",ax=axes[2][0])
axes[2][0].set_title('Vehicle_Age vs Previously_Insured')
sns.pointplot(x='Vehicle_Age', y='Previously_Insured',hue="Response",data=train_prep,ax=axes[2][1])
axes[2][1].set_title('Vehicle_Age vs Previously_Insured w.r.t. Response')

sns.histplot(binwidth=0.5, x="Region_Code_Group", 
                 hue="Vehicle_Age", data=train_prep, 
                 stat="count", multiple="stack",ax=axes[2][2])
axes[2][2].set_title('Region_Code_Group vs Vehicle_Age')
sns.pointplot(x='Region_Code_Group', y='Vehicle_Age',hue="Response",data=train_prep,ax=axes[2][3])
axes[2][3].set_title('Region_Code_Group vs Vehicle_Age w.r.t. Response')

sns.histplot(binwidth=0.5, x="Region_Code_Group", 
                 hue="Previously_Insured", data=train_prep, 
                 stat="count", multiple="stack",ax=axes[3][0])
axes[3][0].set_title('Region_Code_Group vs Previously_Insured')
sns.pointplot(x='Region_Code_Group', y='Previously_Insured',hue="Response",data=train_prep,ax=axes[3][1])
axes[3][1].set_title('Region_Code_Group vs Previously_Insured w.r.t. Response')

sns.histplot(binwidth=0.5, x="Gender", 
                 hue="Policy_Sales_Channel_Group", data=train_prep, 
                 stat="count", multiple="stack",ax=axes[3][2])
axes[3][2].set_title('Gender vs Policy_Sales_Channel_Group')
sns.pointplot(x='Gender', y='Policy_Sales_Channel_Group',hue="Response",data=train_prep,ax=axes[3][3])
axes[3][3].set_title('Gender vs Policy_Sales_Channel_Group w.r.t. Response')

plt.show()

fig, axes = plt.subplots(3, 2, figsize=(15,25))

sns.plot(x='Age_Group', y='Vehicle_Age',data=train_prep,ax=axes[0][0])
axes[0][0].set_title('Age_Group vs Vehicle_Age')
sns.stripplot(x='Age_Group', y='Vehicle_Age',hue="Response",data=train_prep,ax=axes[0][1])
axes[0][1].set_title('Age_Group vs Vehicle_Age w.r.t. Response')

sns.histplot(binwidth=0.5, x="Age_Group", 
                 hue="Previously_Insured", data=train_prep, 
                 stat="count", multiple="stack",ax=axes[1][0])
axes[1][0].set_title('Age_Group vs  Previously_Insured')
sns.stripplot(x='Age_Group', y='Previously_Insured',hue="Response",data=train_prep,ax=axes[1][1])
axes[1][1].set_title('Age_Group vs Previously_Insured w.r.t. Response')

sns.stripplot(x='Age_Group', y='Region_Code_Group',data=train_prep,ax=axes[2][0])
axes[2][0].set_title('Age_Group vs  Region_Code_Group')
sns.stripplot(x='Age_Group', y='Region_Code_Group',hue="Response",data=train_prep,ax=axes[2][1])
axes[2][1].set_title('Age_Group vs Region_Code_Group w.r.t. Response')

plt.show()

"""Observations:

**Age_Group vs Vehicle_Age**: 'Young' customers and 'Old' customers are more likely to have had a car insurance previously, while 'MiddleAged' have the lowest chance of having had an insurance previously.

**Gender vs Vehicle_Damage**: positive correlation

The two plots show that:
* male customers had more damage to their vehicles than female customers;
* male customers with more damage to their cars responded more negatively to the insurance offer than female customers. However, the number of positive responses is similar independent of the gender.

Gender should be taken into consideration as well, because it positively influences Vehicle_Damage which has a strong positive correlation with Response.
"""

fig, (ax1,ax2) = plt.subplots(1, 2, figsize=(15,8))
sns.barplot(x='Gender', y='Vehicle_Damage',data=train_corr,ax=ax1)
ax1.set_title('Gender vs Vehicle_Damage')
sns.lineplot(x='Gender', y='Vehicle_Damage',hue="Response",data=train_corr,ax=ax2)
ax2.set_title('Gender vs Vehicle_Damage w.r.t. Response')
plt.show()

"""**Gender vs Policy Sales Channel Group** : positive correlation

"""

fig, (ax1,ax2) = plt.subplots(1, 2, figsize=(15,8))
sns.barplot(x='Gender', y='Policy_Sales_Channel_Group',data=train_corr,ax=ax1)
ax1.set_title('Gender vs Policy_Sales_Channel_Group')
sns.lineplot(x='Gender', y='Policy_Sales_Channel_Group',hue="Response",data=train_corr,ax=ax2)
ax2.set_title('Gender vs Policy_Sales_Channel_Group w.r.t. Response')
plt.show()

num_attributes = train_corr[['Annual_Premium_Treated', 'Policy_Sales_Channel_Group']]
num_corr_matrix = num_attributes.corr()

fig, (ax1,ax2) = plt.subplots(1, 2, figsize=(15,8))
sns.heatmap(num_corr_matrix, annot=True,fmt="0.2f", ax=ax1)
ax1.set_title('Policy_Sales_Channel_Group vs Annual_Premium_Treated correlation')
sns.pointplot(x='Policy_Sales_Channel_Group', y='Annual_Premium_Treated',data=train_corr,ax=ax2)
ax2.set_title('Policy_Sales_Channel_Group vs Annual_Premium_Treated')
plt.show()

"""After analyzing the correlation between the two numerical features, Policy_Sales_Channel_Group and Annual_Premium_Treated, we found out that they are also slightly negatively correlated, but the correlation value -0.06 is still closer to 0, which means it is subtle and we can keep both features, as they have little influence on each other.

# Data cleaning
## Remove null (empty) values if any

It seems that there are no features with empty values, each has 381109 non-null values, so no line has to be removed or filled with some default value.
"""

# Another way for checking for missing values
train.isnull().sum()

"""## Remove unneccesary features

We clean the dataset by removing the unnecessary features, which don't influence in any way the response, for example:
* **id** of the clients, which is only used to distinguish the different customers.
* **Driving_License** as the majority of the customers own a driving license
* **Annual_Premium** because the majority of the customers pay around the same amount for annual premium.
* **Vintage**, because most of the customers have been with the company for the same amount of time, around 150 days, so it doesn't affect the result much.
* **Policy_Sales_Channel**, **Age** and **Region_Code** can be dropped as well because we introduced their corresponding categorical features: **Policy_Sales_Channel_Group**, **Age_Group** and **Region_Code_Group**.

"""

unnecessary_columns = ['id', 'Age', 'Driving_License', 'Region_Code', 'Annual_Premium', 'Policy_Sales_Channel', 'Vintage']
train = train.drop(columns = unnecessary_columns, inplace = True)
train.head()